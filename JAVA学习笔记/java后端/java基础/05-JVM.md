# 谈谈你对Java的理解

特点

+ 平台无关性，即一次编译，到处运行
+ GC，垃圾回收机制
+ 语言特性。包括 泛型，反射，lambda表达式
+ 面向对象。封装，继承，多态
+ 类库。JDK自带的集合，并发库，IO，网络库等
+ 异常处理。

## 平台无关性

java的开发分为编译期，运行时。

编译期：javac命令。.java文件编译成.class文件。class文件是跨平台的基础

运行时：java 命令，就可以执行.class文件。不同平台不同的jvm，就可以解析成对应平台的机器码来执行。

javap是jdk自带的反编译编辑器 ，可以查看j.class字节码。通过比较字节码和源代码，可以发现很多的问题。可以了解编译器内部工作的机制。

Q：为什么JVM不直接将源码解析成机器码去执行？

A：每次执行的时候，会需要各种检查准备。语法，句法，语义。每次分析的结构都不会被保留下来。都要重新编译，重新去分析，这样整体性能就会收到影响。兼容性方面。也可以将别的语言解析成字节码

# JVM如何加载class文件

## Java虚拟机

虚拟机是一种抽象化的计算机，通过再实际的计算上仿真模拟各种计算机功能来实现的。

JVM有自己的完善架构，如处理器，堆栈，寄存器等。还具有响应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得java程序只需生成再java虚拟机上的目标代码，即字节码。就可以再多种平台上不加修改的运行。

一般情况下，我们不需要知道虚拟机的运行原理， 只要专注写java代码即可。 这也是虚拟机存在的原因，就是屏蔽底层操作系统的不同，减少基于原生语言开发的复杂性。 只要厂商再不同系统上实现了虚拟机，定义如何将字节码解析成本操作系统可执行的二进制码。java就能实现跨越各种平台。

对于jvm来讲，最值得学习的两点，JVM内存结构模型，GC。JVM是是内存中的虚拟机，意味着JVM的存储就是内存，我们所写的类，方法，常量，都在内存中。

![image-20200824211147053](md-images/05-JVM/image-20200824211147053.png)

+ Class Loader：依据特定格式，加载class文件到内存中。
+ Execution Engine:对命令进行解析。即解释器
+ Native Interface：即本地接口，融合不同开发语言的原生库为java所用。不重复造轮子的思想，别的语言开发有了，就用。
+ Runtime Data area :jvm内存空间结构模型。

A：jvm主要分为4个部分组成，Class Loader\Runtime Data area\Execution Engine\Native Interface。通过Class Loader将符合格式的class文件加载到内存当中，并通过Execution Engine去解析class里的字节码，并提交给操作系统去执行。 

# 什么是反射

java的反射机制，是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任何方法和属性。这种动态获取信息以及动态调用对象的功能称为java的反射。

相关API

Class Class.forName:加载某个类

T cls.newInstance() 返回这个类的具体实例

Method cls.getDeclaredMethod("函数名称"，String.class);映射某个方法

mt.invoke(""):方法执行

# ClassLoader

classloader在java中有着非常重要的作用，它主要工作在Class类装载的加载阶段。主要作用是从系统外部获得Class类的二进制流，java的核心组件。所有的Class类都是由Classloader加载的。负责通过将.class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接，初始化等操作。

Q：类从编译到执行的过程

A：首先编译器回将.java源文件编译为.class字节码文件。

ClassLoader将字节码转换为JVM里面的Class<T>对象，获取到的字节码是以byte[]数组传递进来的。

JVM利用Class<T>类对象实例化具体的对象



从代码层面上看，ClassLoader是个抽象类，最重要的一个方法就是loadClass(String name)。通过它才能加载到类，即给定一个类名，去加载一个类，返回代表这个类的实例，如果加载不到就抛出ClassNotFound



## ClassLoader的种类

1. BootStrapClassLoader：加载核心类库 java.* 比如 java.lang.* 。通常这些核心类被签名，不能被替换掉。由JVM内核实现的。C++编写

2. ExtClassLoader：用户可见的ClassLoader，是用来加载位于Jre/lib/ext/这个目录下的jar包。用户也可以将自己自定义的jar放到这个目录下。通过它来加载。java编写的，加载扩展库 javax.*
3. AppClassLoader：java编写，加载程序所在目录。即Classpath路径
4. 自定义Classloader：定制化加载。这个ClassLoader要加载的内容可能不在系统的classpath范围内。甚至可以是不是.class文件或者.java文件。加载方式可以自己来定义。

## 自定义ClassLoader实现

关键函数

+ protected Class<?> findClass(Strign name)：顾名思义，就是寻找.class文件的，包括怎么读这个二进制流。并且做出处理。然后返回Class对象
+ protected final Class<?> defineClass(byte[] b,int off,int len)：定义这么一个类。拿到.class字节流之后，就可以定义(声明)这个类



## ClassLoader的双亲委派机制

不同的Classloader，加载类的方式和路径有所不同。为了实现分工，各自负责各自的区块，使得逻辑更加的明确，采用这种相互共存的ClassLoader。加载类的时候，肯定会按照自己管理的区域各司其职， 所以就存在这么一个机制，让它们相互协作，形成一个整体。这机制就叫做双亲委派机制。

![image-20200825174735343](05-JVM.assets/image-20200825174735343.png)

双亲委派机制：当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。



Q：为什么要使用双亲外派机制去加载类？

A：避免多分同样字节码的加载。内存是宝贵的， 没必要保存相同的两个Class类对象。 

例如：System.Out.Println().实际我们需要的是一个System静态的.class。并且只需要一份，如果不用委派，自己加载自己的，类A打印的时候就会加载一份System.class字节码。类B打印也会加载一份，这样内存中就会有两份。使用了委派机制，那么就会从自定义加载器开始，逐层的像父类去查找。看看哪个Classloader加载过System类。

## 类的加载方式

1. 隐式加载：new

程序再运行过程中，遇到通过new方式生成对象时，隐式调用类加载器，加载对应的类到JVM中。

2. 显示加载：loadClass，forName

 对于显示加载，需要调用Class对象的newIntance()来生成对象的实例。new隐式加载则无需通过newInstance()来生成实例。并且new支持带参数的构造器，Class对象的newInstance()方法 不支持传入参数，需要通过反射，调用构造器对象的newInstance()方法，才能支持参数。



Q：loadClass和forName的区别

A：

+ 都能再运行期间，对任意一个类，都能知道该类的所有属性和方法。对于任意对象，都能够调用它的任务方法和属性。
+ Class.forName:得到的Class是已经完成初始化的
+ ClassLoader.loadClass的到的Classs是没有链接的。只完成了类装载的第一步。

作用：想以下JDBC的驱动包使用，有的要立即初始化驱动。不用立马初始化的，可以加快类的加载速度，留到实际使用到的时候再进行初始化。



## 类的装载过程

加载是装载的其中一个部分，

1. 第一步：加载--通过ClassLoader加载class文件字节码，生成Class对象。
2. 第二部：链接
   + 校验：检验加载的class文件的正确性和安全性
   + 准备：为类变量分配存储空间并设置类变量的初始值
   + 解析：JVM将常量池内的符号引用转换为直接引用
3. 第三部：初始化--执行类变量赋值和静态代码块。

# Java内存模型

内存相关知识：

计算机所有程序都是内存中运行的，只不过这个内存可能包括虚拟内存，同时也离开硬盘这样的外存知识。在程序执行的过程中，需要不断的将内存的逻辑地址，和物理地址进行映射，找到相关的指令，以及数据去执行。

作为操作系统进程，java运行时，面临着于其他进程完成相同的内存限制，即：受限制操作系统架构 提供的可寻址地址空间。操作系统提供的可寻址地址空间，由处理器的位数决定(32位/64位)。32位处理器提供2^32的可寻址范围(4GB)。64位处理器提供2^64的可寻址范围(百亿字节)。

地址空间的划分：

+ 内核空间：内核空间是主要的操作系统程序和C运行时的空间，包含用于连接计算机硬件，调度程序，以及提供联网和虚拟内存等服务的逻辑和基于C的进程。
+ 用户空间：用户空间才是Java实际运行时使用的内存空间。32位系统用户进程最大可用访问3GB，内核代码可用访问所有物理内存。而64位系统用户进程最大可用访问超过512GB。内核代码同样可用访问所有物理内存。







![image-20200825222458821](md-images/05-JVM/image-20200825222458821.png)

## JVM内存模型--JDK8

java程序运行在JVM虚拟机之上，运行时需要内存空间，虚拟机执行Java程序的过程中，会把它管理的内存划分为不同的数据区域方便管理。比如C语言，C编译器在划分内存区域的时候， 经常将管理的区域划分为数据段，和代码段。数据段包括堆栈，以及静态数据区。

JDK8作为研究模型，JDK9和11都差不多。

我们可以将JVM内存模型，从线程的角度和存储的角度去看它的模型结构。

![image-20200825233917804](md-images/05-JVM/image-20200825233917804.png)

线程的角度：即哪些区域是线程私有的，哪些区域是线程共享的来分类。

私有：

+ 程序计数器：一块较小的内存空间，其作用是【当前线程所执行的字节码的行号指示器(逻辑)】。在虚拟机的概念模型里，字节码解释器就是【改变计数器的值，来选取下一条需要执行的字节码命令】。包括分支，循环，跳转，异常处理，线程恢复等基础功能，都需要依赖这个计数器来完成。由于JVM的多线程，是通过线程轮流切换，并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器，只会处理一条线程中的指令，因此为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的计数器。各条线程之间的计数器，互不影响，独立存储。我们称这类内存区域为线程私有的内存。【计数器和线程是一对一的关系，即“线程私有”】。如果【线程正在执行一个JAVA方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Native方法，这个计数器的值为Undefined】。此外，由于只是记录行号，程序计数器【不用担心内存泄露问题】。关键词：程序计数器是逻辑计数器，而非物理计数器。为了线程切换后都能恢复正确的执行位置，每个线程都有一个独立的计数器，并且治位JAVA方法计数，native方法的计数器值为 undefined，使用不用担心内存泄露。
+ 虚拟机栈：也是线程私有的。是【Java函数执行的内存模型】。每个函数被执行时，都会创建一个栈帧，即函数运行时期间的基础数据结构，栈帧用于存储局部变量表，操作树栈，动态连接，方法出口等。每个方法执行中，对应虚拟机栈帧从入栈到出栈的过程。java虚拟机栈，用来存储栈帧，而栈帧持有局部变量和部分结果以及参与方法的调用于返回，当方法调用结束时，栈帧才会被销毁。关键词:虚拟机栈包含了每个方法执行的栈帧，栈帧则存储了局部变量表，操作数栈，动态连接，方法出口等信息。虚拟机栈也是java虚拟机自动管理的，栈类似于一个集合，有固定的容量，是由多个栈帧合起来的。在编程时，没调用一个方法，在运行的时候，java虚拟机就会自动在内存中分配对应的一块空间，这块空间就是一个栈帧。而当方法调用结束后，对应的栈帧就会被自动释放掉。这就是通常说说的栈的内存不需要通过GC回收，而会自动释放的原因。
  + 局部变量表：包含了方法执行过程中的所有变量。包括，this引用，所有方法参数，其他局部变量，和基本数据类型。
  + 操作数栈：在执行字节码指令过程中被用到，类似于CPU原生寄存器，大部分JVM字节码把时间花费在操作数栈的操作上，包括入栈，出栈，复制，交换，产生消费变量的操作。因此，局部变量表和操作数栈的交换变量指令操作，通过字节码频繁执行。
+ 本地方法栈：与虚拟机栈非常类似，主要作用与标注了native的方法。

共享：

+ MetaSpace：即元空间，在JDK8以后，开始把类的元数据放在本地堆内存中这一块区域。该区域在JDK7以前，是属于永久代(PermGen)的。元空间和永久代都是用来存储Class的相关信息。包括Class对象的Method等。实际上，元空间和永久代，均是方法区的实现，只是实现有所不同。所有说，方法区只是一种JVM的规范。在JAVA7之后，原先位于方法区里的字符串常量池，已经被移动到java堆中，并且在JDK8之后，使用元空间替代了永久代。两者最大的区别，元空间使用本地内存，而永久代使用的是JVM的内存。使用本地内存的好处最直接的表现在java.lang.OutOfMenoryError:PermGen space这个异常就不复存在。因为默认类的元数据分配，只受本地内存大小的限制。理论上，本地内存多少，MateSpace就可以有多大，解决空间不足的问题。JVM默认在运行时候会根据需要动态的设置其大小。MetaSpace相比永久代的优势，【字符串常量池在永久代中，容易出现性能问题和内存溢出。类和方法的信息大小难以确定，给永久的大小带来困难。】太小容易导致永久代溢出，太大容易导致老年代溢出。【永久代会给GC带来不必要的复杂度，】并且回收效率偏低。在永久代中，元数据可能会随着每一次父GC发生，而进行移动。HotSpot每种垃圾回收器，都需要特殊处理永久代中的元数据。分离出来以后，可以简化父GC，以及对以后的并发隔离元数据等方面进行优化。【 方便HotSpot与其他JVM如Jrockit继承】。永久代是 HotSpot vm实现特有的，而别的vm没用永久代的说法。 我们只需要重点记住，它和永久代的区别。
+ Java堆常量池：即Heap。对象实例的分配区域。是JVM管理最大的一块区域，是被所有线程共享的一块区域。在虚拟机启动时创建，唯一目的就是存放对象实例。几乎所有的对象实例都在这里分配内存。也是GC管理的主要区域，很多时候也被称为GC堆。

![image-20200826210938093](md-images/05-JVM/image-20200826210938093.png)

![image-20200826211326069](md-images/05-JVM/image-20200826211326069.png)



![image-20200826223824404](md-images/05-JVM/image-20200826223824404.png)



Q：递归为什么会引发java.lang.StackOverflowError异常

A：递归过深，栈帧数超出了虚拟机栈的深度。同时可能还会引发内存溢出的异常。

# 性能调优

## 三大性能调优参数

JVM三大性能调优参数 -Xms -Xmx -Xss的含义

在调用指令java -Xms 128m -Xmx 128m -Xss 128m -jar xxx.jar运行程序的时候，传入以上参数，去分别调整java的堆，以及线程所占内存的大小。

-Xms：堆的初始值。Java堆。即进程刚创建出来的时候，专属JAVA堆的大小。 一旦对象的容量超过了JAVA堆的初始化容量，JAVA堆将会自动扩容。扩容到Xmx的设置大小。

-Xmx：堆能达到的最大值。

-Xss：规定了每个线程虚拟机栈(堆栈)的大小。一般256m足够了，此配置将会影响进程中线程并发数的大小。

通常情况下，Xms和Xmx设置成一样的大小，因为当堆Heap不够用而发生扩容时，会发生内存抖动，影响程序运行时的稳定性。

## Java内存模型中堆栈的区别

Java内存模型中堆栈的区别，要想弄明白这个问题，得先明白程序运行时内存分配策略。

程序运行时候，由三种内存分配策略。静态的，栈式的，堆式的。

静态存储：编译时就能够确定每个数据目标，在运行时的存储空间需求。因此，在编译时，就可以给它们分配固定的内存空间。这种分配策略，要求代码中，不允许有可变数据结构的存在，也不允许有嵌套或者递归的结构出现。因为它们都会导致编译程序，无法计算准确的存储空间。

栈式存储：该分配可成为动态的存储分配。是由一个类似于堆栈的运行栈来实现的。和静态存储的方式相反。在栈式存储方案中，程序对数据区的要求大小是完全未知的，只有到了运行时才能知道。但是规定在运行中，进入一个程序模块的时候，必须就要知道该程序模块所需要的数据区的大小，才能分配内存。栈式存储，按照先进后出的原则进行分配。

堆式存储：专门负责在编译时和运行时，模块入口处都无法确定存储要求的数据结构的内存分配，比如可变长度串，和对象实例。堆由大片的可利用块或空闲块组成。堆中的内存可以按照任意顺序分配和释放，动态分配。

然后是堆和栈的联系。

联系：我们知道创建好的数组，或者对象实例，都会被保存在堆中。栈中定义变量保存堆中目标的首地址。以后就可以使用栈中的引用变量来访问数组或者对象。引用变量相当于是为数组或者对象起的名称，是普通的变量，定义时在栈中分配，引用变量在程序运行到起作用域之外后，就会被释放。而数组和对象本身在堆中分配，即使程序运行到使用new产生数组或者对象语句所在的代码块之外，数组和对象本身占据的内存，不会被释放。它们在没有引用变量指向的时候，才会变为垃圾，需要等待不确定的时间被GC回收释放掉。

Q：Java内存模型中堆和栈的区别

+ 管理方式：栈自动释放，堆需要GC回收
+ 空间大小：栈比堆小。
+ 碎片相关：栈产生的碎片远小于堆。针对堆空间而言，即使GC回收器能自动进行堆内存回收，但是堆空间的活动量相对栈空间而言比较大，很由可能存在长期的堆空间分配和释放操作。而且GC回收期不是实时的。由可能使得堆空间的内存碎片逐渐累积起来。针对栈，本省就是一个堆栈的数据结构，操作都是一一对应的。而且每一个最小单位的结构栈帧，和堆空间内复杂的内存结构不一样，所以一般很少出现内存碎片。
+ 分配方式：栈支持静态和动态分配，而堆只支持动态分配。 
+ 效率：栈的效率高于堆。内存块的排列本身就是一个堆栈结构。所以栈比堆效率要高很多。  操作也简单，就两个指令，出栈和入栈。



# JDK版本的差异

比较有代表性就是字符串的 intern()方法。 差异体现在JDK6于JDK6+

Q：字符串 intern() JDK6于JDK6+的区别

A：JDK6:方法调用时，如果字符串常量池中先前已经创建出改字符串对象，则返回池中改字符串的引用。否则将这个字符串对象添加到字符串常量池中，并且返回该字符串对象的应用。

JDK6+：方法调用时，如果字符串常量池已经创建改字符串对象，则返回池中该字符串的引用。否则，如果该字符串对象存在JAVA堆中，则将堆中堆这个字符串的【引用】添加到字符串常量池中，并且返回该引用。如果不存在，则在池中创建该字符串对象并返回这个引用。