# GC垃圾回收机制

 Q：对象被判断为垃圾的标准

A：  没有被其他对象引用

Q：判断对象是否为垃圾的算法

A：引用计数算法和可达性分析算法

Q：谈谈你了解的垃圾回收算法

垃圾回收算法主要有：标记-清除算法， 

## 引用计数算法

+ 通过判断对象的引用数量，来决定对象是否可以被回收。
+ 堆中每个对象实例都有一个引用计数器，被用于则+1，完成引用则-1。当一个对象被创建时，该对象实例分配一个引用变量，该对象的引用计数就会被设置1 ，若该对象又被另外一个对象引用，则+1。当该对象实例的某个引用超过了生命周期，  或该对象的引用被设置为新值时，这个对象计数会-1。
+ 任何引用计数为0的实例是可以被当作垃圾回收的。

优点：

+ 执行效率高，程序执行受影响较小

缺点：

+ 致命短板，无法检测出循环引用的情况，导致内存泄露。子对象引用父对象，父对象引用子对象。

## 可达性分析算法

+ 通过判断对象的引用链是否可达，来决定对象是否可以被回收
+  可达性算法是通过离散数学中的图论引入的。

可以作为GC Root的对象

+ 虚拟机栈中的引用对象（栈帧中的本地变量列表）

+ 方法区中的常量引用的对象。
+ 方法区中的类静态属性应用对象
+ 本地方法栈中JNI(Native方法)的引用对象
+ 活跃线程的引用对象



## 标记-清除算法

就是将回收分为两个阶段。主要不足是会产生内存碎片。清除时候不需要进行对象移动，并且仅对不存活的对象进行处理，清除后就会产生大量不连续的碎片。 空间碎片太多，可能会导致以后程序运行过程中，需要分配一个较大内存的对象时，无法找到足够的连续内存，而不得不提前触发一次垃圾收集动作。

+ 标记：先从根集合进行扫描，对存活的对象进行标记。然后可达性算法来找到垃圾对象。 
+ 清除：标记完毕后，对堆内存从头到尾进行线性遍历，回收不可达对象内存。回收完毕后，将之前标记为可达的标记清除，以便进行下一次垃圾回收。

## 复制算法

复制算法主要按容量按比例划分两块或多个块。并选择其中一块或两块作为对象面，其他作为空闲面。对象主要在对象面创建，当被定义为对象面块的内存用完，就将还存活的对象从对象面复制到其中一块空闲面。然后再把已使用过的内存空间一次性清理掉。这种算法适用于对象存活率低的场景。这样使得每次都对整个半区进行内存回收，内存分配时，就不用考虑内存碎片的复杂情况。

+ 分为对象面和空闲面
+ 对象在对象面上创建
+ 存活的对象从对象面复制到空闲面
+ 将对象面的所有对象内存清除。 
+ 解决碎片化问题
+ 顺序分配内存，简单高效
+ 适用于对象存活率低的场景。



复制收集算法在应对对象存活率较高的情况时候，就有点力不从心，要进行较多复制操作，效率就会变低，更关键的是如果不想浪费50%的空间，就需要有额外的空间进行担保，以应对被使用的内存中，所有对象都100%存活的极端情况。 老年代的空间不能使用这种算法。



## 标记-整理算法

适合用在老年代的对象回收。采用标记清除算法一样的方式，进行对象的标记，但在清除时不同，在清除的过程中，移动所有存活的对象，且按照内存地址次序一次排列，然后将末端内存以后的内存全部回收。该算法在标记-清除的算法上又进行了移动 ，因此成本更高，但是确解决了内存碎片的问题。

+ 标记：从根集合进行扫描，对存活对象进行标记。
+ 清除：移动所有存活的对象，且按照内存地址次序一次排列，然后将末端内存以后的内存全部回收
+ 避免了内存的不连续性
+ 不用设置两块内存互换
+ 适用于对象存活率高的场景。 



## 分代收集算法

+ 垃圾回收算法的组合拳
+ 按照对象生命周期的不同划分区域，以采用不同的垃圾回收算法
+ 目的：提高JVM的回收效率

### 分代收集算法GC分类

Minoc GC：是发生在年轻代中的垃圾收集动作，所采用的是复制算法。年轻代几乎是所有java对象出生的地方，即java对象申请的内存以及存放都在这里进行。java中的大部分对象通常不需要长久的存活，具有朝生熄灭的性质，当一个对象判定为死亡的时候，GC就有责任来回收这部分对象的内存。新生代是垃圾回收的频繁区。每次Eden区放不下，会触发一次Minoc GC回收。

+ Eden区：伊甸园，代表人类起源，对象刚被创建出来，其内存空间首先在这里分配，如果放不下，就会放在Survivor老年代中
+ 两个Survivor区。分别定义为from区和to区。 会随着垃圾回收而相互转换。

Q:对象如何晋升到老年代

+ 经历一定的Minor次数依然存活的对象 ，默认是15岁
+  Survivor区中存放不下的对象。
+ 新生成的大对象。-XX:+PretenuerSizeThreshold

Q:常用的调优参数

+ -XX:SurvivorRatio : Eden和Survivor的比值，默认8：1
+ -XX：newRatio：老年代和年轻代内存大小比例
+ --XX:MaxTenuringThreshold ：对象从年轻带到老年代经过GC次数的最大阈值。

Full GC：与老年代相关。由于对老年代的回收一般会伴随着年轻代的垃圾收集，因此被命名为Full GC。在年轻代经历了N次垃圾回收，依然存活的对象，就会被放到老年代中，老年带存放的都是生命周期较长的对象。老年内的内存要比年轻代内存要大。采用标记清理算法或者标记整理算法。当触发老年代的GC回收，通常也会伴随着年轻代的GC的回收。即对整个堆进行回收。

+ 存放生命周期较长的对象。
+ MajorGC 和 Full GC 的等价的。
+ Full GC比Minor GC慢，执行效率低。

Q：触发Full GC的条件

+ 老年代空间不足。
+  永久代空间不足，针对JD7以前。
+ GMS GC出现 primotion faile,concurrent mode failure
+ Minor GC晋升到老年代的平均值大于老年代的剩余空间
+ 调用System.gc()
+ 使用RMI来进行RPC或管理的JDK应用，每小时候进行1次Full Gc回收。



### Stop-the-world

JVM有要执行GC而停止了应用程序的执行，平且这种情形会在任何一种GC算法中都会发生。当Stop-the-world发生时，除了GC所需的线程意外，所有线程都处在等待状态，直到GC任务完成。GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有高吞吐低停顿的特点。

+ JVM有要执行GC而停止了应用程序的执行
+ 任何一种GC算法中都会发生
+ 多数GC优化通过减少Stop-the-world发生的事件来提高程序新能

### Satepoint

即安全点。JVM垃圾回收就好比是保洁阿姨在打扫卫生，保洁阿姨在开始打扫前，会和所有人说，我要打扫了，你们不准仍垃圾了。防止一边打扫一边有人在仍垃圾的情况。JVM垃圾回收，如何解决上面的情景。在可达性算法中，要分析哪个对象没有引用的时候，必须在一个快照的状态点进行，在这个点，所有的线程都被暂停，不可出现分析过程中，对象引用关系还在不停变化的情况。因此，分析结果需要在某个节点具备确定性。该节点变叫做安全点。程序不是随便哪个点就停顿下来，而是达到安全点才会停顿下来。一般在方法调用，循环跳转，异常跳转等，才会产生安全点。一旦GC发生让所有的线程都跑到最新的安全点在停顿下来，如果发现线程不在安全点，就恢复线程等待它跑到安全点。安全点的选择，即不能太少，也不能太多。太少会让GC等待太长的时间，太多会增加程序运行的负荷。

+ 分析过程中对象引用关系不会发生变化的点。
+ 产生Satepoint的地方：方法调用；循环跳转；异常跳转等
+ 安全点数量得适中

### 常见的垃圾收集器

#### 年轻代垃圾收集器

##### Serial收集器：

-XX:+UseSerialGC  复制算法

Serial收集器是JAVA虚拟机中最基本，历史最久的收集器。在JDK1.3之前，是JAVA虚拟机年轻代的唯一选择。采用单线程的收集，它单线程意义，不仅仅是说只会适用一个cpu或一条收集线程完成垃圾回收。它进行垃圾收集时，必须暂停所有的工作线程。到现在为止，它依然是虚拟机运行在Client模式下默认年轻代的收集器，因为它简单，高效。

+ 单线程收集，进行垃圾收集时，必须暂停所有工作线程
+ 简单高效，Client模式下默认的年轻代收集器



##### ParNew收集器：

-XX:+UseParNewGC，复制算法

除了多线程收集，其余的行为，和Serial收集器一样。Server模式下首选的年轻代收集器。在单个CPU环境中，不会有比Serial收集器有更好的效果，因为存在线程切换的开销。随着可用CPU数量的增加，对于GC池，系统资源的有效利用，还是很有好处的。默认开启的收集线程数，与CPU核心数相同，在CPU数量非常多的情况下，可用使用-XX:+ParGCThread参数来限制垃圾收集的线程数。

+ 除了多线程收集，其余的行为，和Serial收集器一样
+ 单核执行效率不如Serial，在多核下执行才有优势



##### Parallel Scavenge收集器：

-XX:+UseParallelGC  复制算法

运行用户代码时间100分钟，垃圾收集2分钟，吞吐量久是98%。类似于ParNew收集器，也是复制算法，也是使用多线程垃圾回收，比起前面尽可能缩短垃圾收集时用户线程停顿的时间，它更关注系统的吞吐量。停顿时间短，适合需要与用户交互的程序，良好的响应速度，能提升用户体验。高吞吐，则可用高效率利用CPU时间，尽可能快的完成运算任务。适合在后台运算，而不需要太多交互任务的情况。 Server模式下默认年轻代的收集器。如果对垃圾收集运作原理不太了解，优化过程中遇到困难，可用使用-XX:+UseAdaptiveSizePolicy自适应调节策略，回把内存管理的调优任务交给虚拟机完成

+ 吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)
+ 比起关注用户线程的停顿时间，它更关注系统的吞吐量
+ 在多核下执行才有优势，Server模式下默认年轻代的收集器



#### 老年代垃圾收集器

##### Serial old收集器：

-XX:+UseSerialOldGC 标记-整理算法

+ 单线程收集，进行垃圾回时，必须暂停所有工作线程
+   简单高效，Client模式下默认的老年代收集器

Parallel Old收集器：-XX：+UseParallelOldGC 标记-整理算法

+ 多线程，吞吐量优先



##### CMS收集器：

-XX:+UseConcMarkSweepGC  标记-清除算法

CMS收集器几乎占据着老年代垃圾收集器的半壁江山，它划时代的意义就是垃圾回收线程，几乎能与用户线程做到同时工作，几乎是因为还是不能完全做到Stop-the-world，只是尽可能缩短了停顿时间。如果应用程序对停顿比较敏感，并且在应用程序运行的适合能提供更到的内存，和更多的CPU，那么使用CMS来收集会带来好处。还有JVM中有相对较多的存活时间长的对象，会更适合使用。

垃圾回收过程

+ 初始化标记：stop-the-world
+ 并发标记：并发追溯标记，程序不会停顿
+ 并发预清理：查询执行并发标记阶段从年轻代晋升到老年代的对象
+ 重新标记：暂停虚拟机，扫描CMS堆中剩余的对象
+ 并发清理：清理垃圾对象，程序不会停顿
+ 并发重置：重置CMS收集器的数据结构



##### G1收集器：

即Garbage First收集器

-XX:UseG1GC  复制+标记-整理算法

+ 将整个JAVA堆内存划分成多个大小相等的Region
+ 年轻代和老年代不在物理隔离

既用于年轻代，也用于老年代的收集。 它的使命是未来可用替换掉JDK5中的CMS收集器。与其他收集器相比

特点

+ 并发和并行
+ 分代收集
+ 空间整合
+ 可预测的停顿



### JVM的运行模式

Server:启动速度慢，进入稳定期后，要比Client要快。因为Server采用的是重量级的虚拟机，对程序采用了更多的优化

Client:启动速度快。采用的是轻量级的虚拟机。





## 面试题

Q：Object的finalize()方法的作用是否与C++的析构函数作用相同

A：

+ 与C++的析构函数不同，析构函数调用确定，而它的是不确定的。
+ 将未被引用的对象放置于F-Queue队列
+ 方法执行随时可能会被终止
+ 给与对象最后一次重生的机会

C++中的析构函数，调用的时机是确定的，即对象离开作用域后，就会被Delete掉。Java中的finalize()调用具有不确定性。当垃圾回收期要宣告一对象死亡时，至少要经过两次的标记过程，如果对象在进行可达性分析后，发现每有和GC ROOTS相连的引用链，就会被第一次标记，并且判断是否执行finalize()，如果对象覆盖finalize()，且未被引用过，这个对象就被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的低优先级的finalize()线程去执行触发finalize()方法。由于优先级低，触发方法后不承诺等待其运行结束，即方法执行随时可能会被终止。 它的作用是为对象创造一次逃脱死亡的机会。



Q：Java中的强引用，软引用，弱引用，虚引用有什么用途。

A：

强引用:

+ 最普遍的引用:Object obj = new Object();
+ 当内存空间不足的时候,Java虚拟机宁可抛出OutOfMemoryError终止程序也不会回收具有强引用的对象
+ 如果不使用对象了，通过设置为null来弱化引用，使其被回收。或者等待超出作用域范围，GC就会认为该对象不存在引用，就可用被GC回收。

软引用：

+ 表示一个对象有用，但非必须的状态
+ 如果一个对象具有软引用，在内存空间充足时，GC就不会回收该对象，当内存空间不足时，GC会回收该对象的内存
+ 可用用来实现内存敏感的高速缓存

```java
String str =new String("abc");//强引用
SoftReference<String> softRef = new SoftReference<String>(str); //软引用
```

弱引用：

+ 非必须的对象，强度比软引用更弱一些
+ 具有更短的生命，GC扫描时发现具有弱引用关联的对象，就会被回收。无论内存是否紧缺
+ 被回收的概率也不大，因为GC线程优先级比较低
+ 适用于引用偶尔使用且不影响垃圾回收的对象

用法和软引用是一样的

需引用:

+ 不会决定对象的生命周期
+ 任何时候都可能被垃圾收集器回收，相当于没有任何引用
+ 主要用来跟踪对象被垃圾收集器回收的活动，起哨兵作用
+ 必须和引用队列ReferenceQueue联合使用

```java
String str =new String("abc");//强引用
ReferenceQueue queue = new ReferenceQueue();
PhantomReference ref = new PhantomReference(str，queue);

```



引用级别: 强引用>软引用>弱引用>需引用

![image-20200902002330482](md-images/06-GC垃圾回收/image-20200902002330482.png)



引用队列：ReferenceQueue

+ 无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达的
+ 存储关联的且被GC的软引用，弱引用以及虚引用